通过linux下shell实现原理的探索，我们决定实现：

1. 以shell系统为核心文件，通过核心内的fork/exec相关函数跳转到键入命令的自实现程序，从而实现shell的命令执行功能。

2. 自实现命令程序相关：通过whereis这个命令，我们可以得知linux下命令程序通常是存储在/usr/bin文件夹下。
故我们组的自实现命令程序被存放在shell文件夹内的./bin目录下。

3. 我们通过每一个独立自实现程序的main函数内的argc与argv参数，传入命令参数，从而根据参数执行不同的内容。
例如在ls命令程序内，通过argv参数得知执行的为ls-l还是ls或是ls -l | more。

4. 实验报告中要求实现history与!相关内容，由于我的shell为独立程序，与自实现命令程序相互独立，故我把history与!的相关内容实现在shell内。
由此shell在接收命令后，首先应该判断为内部命令或是外部命令。若为外部命令则跳转外部程序执行，若为内部命令(history/!!/!N)则直接执行。

5. history的数据结构我采用pair<int,list>，简单明了，int为程序history记录的起始id(因为要求只存10条消息)，list则为历史输入字符串链表。
当list内不足10条时，则直接在list内添加；若已经为10条，则int存储的id++，list链表pop出头信息，把新信息push进链表尾，即可实现history的储存。
当执行history命令时，直接遍历list即可。执行!!与!N时，通过list读取输入内容，随后执行该命令即可。

6. 切割命令字符串通过判定空格来切割。

7. fork和exec原理啥的

8. &后台执行：如果检测到最后一个参数为& 
create新线程来保证输入不会被阻塞，从而实现后台执行